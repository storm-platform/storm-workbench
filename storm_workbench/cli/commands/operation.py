# -*- coding: utf-8 -*-
#
# Copyright (C) 2021 Storm Project.
#
# storm-workbench is free software; you can redistribute it and/or modify it
# under the terms of the MIT License; see LICENSE file for more details.

import json
import click
import rich.markdown

from pathlib import Path

from storm_core.parser import ShellCommandParser, load_stormfile

from storm_workbench.workbench import Workbench
from storm_workbench.cli.graphics.aesthetic import aesthetic_print


@click.group(name="op")
@click.pass_context
def operation(ctx):
    """Reproducible experiment executions."""
    if ctx.obj is None:
        ctx.obj = dict()

    ctx.obj["workbench"] = Workbench()


@operation.command(name="run")
@click.argument("command", required=False, nargs=-1)
@click.option(
    "-sf",
    "--stormfile",
    required=False,
    type=click.Path(
        exists=True, resolve_path=True, path_type=Path, dir_okay=False, file_okay=True
    ),
)
@click.pass_obj
def run(obj, command=None, stormfile: Path = None):
    """Execute an arbitrary command in a reproducible way.

    When the execution is done by the `Storm Workbench`, all computational components used on the execution will be
    registered transparently. With this, after the execution the experiment can be reproduced without many efforts.
    For example, if you want to run a python script and then reproduce it, you can use `Storm Workbench` to help you.

    To do this, the execution that is normally done like this:
       $ python3 myscript.py

    should look like this:
       $ workbench operation execute python3 myscript.py

    The main difference here is that now, the execution is controlled by `Storm Workbench`, which allows you to extract
    information from the execution and save all the elements needed to re-run the project.
    """
    aesthetic_print("[bold cyan]Storm Workbench[/bold cyan]: Reproducible execution", 0)

    execution_plan = None
    if command:
        execution_plan = ShellCommandParser.parse(list(command))

    elif stormfile:
        execution_plan = load_stormfile(stormfile)

    else:
        aesthetic_print("[bold red]Storm Workbench[/bold red]: Problems founded", 0)
        aesthetic_print(
            rich.markdown.Markdown(
                "To run a reproducible command you need to define a ``command`` or specify "
                "a Stormfile (``--stormfile``)."
            ),
            0,
        )

        return

    try:
        workbench = obj["workbench"]
        workbench.session.op.execute(execution_plan)

        workbench.session.save_session()
    except RuntimeError:
        aesthetic_print("[bold red]Storm Workbench[/bold red]: Problems founded")
        aesthetic_print(
            rich.markdown.Markdown(
                "A new command cannot be executed, there are commands in the "
                "execution graph that need to be **updated**. You can check the graph "
                "status using `workbench graph show --as-table-status`."
                "To update the graph you can use the `bdcrrm-cli production remake` "
                "command."
            )
        )
    # except BaseException as e:
    #     aesthetic_print("[bold red]Storm Workbench[/bold red]: Problems founded")
    #     aesthetic_print(
    #         rich.markdown.Markdown(f"Error to register the specified command: {e}")
    #     )


@operation.command(name="update")
@click.pass_obj
def update(obj):
    """Update outdated commands.

    The command `rerun` identifies and re-executes all outdated commands.
    This option is useful when multiple runs need to be rerun because of changing results from other scripts.
    A vertex command is considered outdated when any of its predecessors have a run performed after its creation.

    For example:
      The execution graph below has three associated commands:
         *(Command 1) -> *(Command 2) -> *(Command 3)

    All are up to date (Imagine). If the vertex `Command 2` is executed again, all its subsequent ones will
    be out of date since they depend on the result generated by this command. Following this rule, in this
    example, the vertex `Command 3` is outdated.
    Using the `remake` command, the out-of-date nodes are automatically identified and re-executed.
    """
    aesthetic_print("[bold cyan]Storm Workbench[/bold cyan]: Reproducible (re)run", 0)

    workbench = obj["workbench"]

    workbench.session.op.rerun()
    workbench.session.save_session()

    aesthetic_print("[bold cyan]Storm Workbench[/bold cyan]: Finished!", 0)


@operation.command(name="rerun")
@click.option(
    "--output-directory",
    required=True,
    type=click.Path(
        exists=True, resolve_path=True, path_type=Path, dir_okay=True, file_okay=False
    ),
)
@click.option(
    "-files",
    "--required-files-reference",
    required=False,
    type=click.Path(
        exists=True, resolve_path=True, path_type=Path, dir_okay=False, file_okay=True
    ),
)
@click.option("-env", required=False, multiple=True)
@click.pass_obj
def rerun(obj, output_directory: Path, required_files_reference: Path, env):
    """Reproduce existing experiment."""
    aesthetic_print("[bold cyan]Storm Workbench[/bold cyan]: Experiment reproduction.")
    workbench = obj["workbench"]

    if required_files_reference:
        aesthetic_print(
            "[bold cyan]Storm Workbench[/bold cyan]: Loading the required files reference.",
            1,
        )

        required_files_reference = json.load(required_files_reference.open())

    aesthetic_print(
        "[bold cyan]Storm Workbench[/bold cyan]: Reproducing the experiment.", 0
    )
    workbench.session.op.reproduce(
        output_directory, required_files_reference or None, env or None
    )

    aesthetic_print("[bold cyan]Storm Workbench[/bold cyan]: Finished.", 0)
