# -*- coding: utf-8 -*-
#
# Copyright (C) 2021 Storm Project.
#
# storm-workbench is free software; you can redistribute it and/or modify it
# under the terms of the MIT License; see LICENSE file for more details.

import json
from pathlib import Path
from zipfile import ZipFile

import click
import rich.markdown
from storm_core.helper.exporter import BagItExporter
from storm_core.parser import ShellCommandParser, load_stormfile

from storm_workbench.cli.graphics.aesthetic import aesthetic_print, aesthetic_traceback
from storm_workbench.constants import WorkbenchDefinitions
from storm_workbench.workbench import Workbench


@click.group(name="op")
@click.pass_context
def operation(ctx):
    """Reproducible operations."""
    if ctx.obj is None:
        ctx.obj = dict()

    try:
        ctx.obj["workbench"] = Workbench()
    except:
        aesthetic_traceback(show_locals=True)

        exit()


@operation.command(name="run")
@click.argument("command", required=False, nargs=-1)
@click.option(
    "-sf",
    "--stormfile",
    required=False,
    type=click.Path(
        exists=True, resolve_path=True, path_type=Path, dir_okay=False, file_okay=True
    ),
    help="Stormfile with the processing Pipeline definition.",
)
@click.pass_obj
def run(obj, command=None, stormfile: Path = None):
    """Execute an arbitrary command in a reproducible way.

    When the execution is done by the `Storm Workbench`, all computational components used on the execution will be
    registered transparently. With this, after the execution the experiment can be reproduced without many efforts.
    For example, if you want to run a python script and then reproduce it, you can use `Storm Workbench` to help you.

    To do this, the execution that is normally done like this:

       $ python3 myscript.py

    with the Storm Workbench will look like this:

       $ workbench op run python3 myscript.py

    The main difference here is that now, the execution is controlled by `Storm Workbench`, which allows you to extract
    information from the execution and save all the elements needed to reproduce the execution.

    This command is created using the ReproZip tool. Many thanks to the ReproZip team.
    """
    aesthetic_print(
        "[bold cyan]Storm Workbench[/bold cyan]: Reproducible Execution :crystal_ball:",
        0,
    )

    # parsing the command that will
    # be executed.
    aesthetic_print(
        "[bold cyan]Storm Workbench[/bold cyan]: Parsing the command :key:", 1
    )

    execution_plan = None
    try:
        if command:
            execution_plan = ShellCommandParser.parse(list(command))

        elif stormfile:
            execution_plan = load_stormfile(stormfile)

        else:
            aesthetic_print(
                "[bold red]Storm Workbench[/bold red]: Problems founded :disappointed_relieved:",
                0,
            )
            aesthetic_print(
                rich.markdown.Markdown(
                    "To run a reproducible command you need to define a ``command`` or specify "
                    "a Stormfile (``--stormfile``)."
                ),
                0,
            )

            return
    except:
        aesthetic_traceback(show_locals=True)

    # running!
    aesthetic_print("[bold cyan]Storm Workbench[/bold cyan]: Running :fire:", 1)

    try:
        workbench = obj["workbench"]
        workbench.session.op.run(execution_plan)

        workbench.session.save_session()
    except RuntimeError:
        aesthetic_print(
            "[bold red]Storm Workbench[/bold red]: Problems founded :disappointed_relieved:"
        )
        aesthetic_print(
            rich.markdown.Markdown(
                "Some commands are **outdated**! Update them to export the compendium."
            )
        )
    except:
        aesthetic_traceback(show_locals=True)


@operation.command(name="update")
@click.pass_obj
def update(obj):
    """Update outdated executions.

    This command identifies and re-executes all outdated executions, which is useful when multiple runs need to be
    updated because of changing results from other scripts. An execution is considered outdated when any of its
    predecessors have a run performed after its creation.

    For example, below we have three associated executions:

         *(Execution 1) -> *(Execution 2) -> *(Execution 3)

    All are up to date (Imagine). If the `Execution 2` is executed again, all its subsequent ones will
    be out of date since they depend on the result generated by this Execution. Following this rule, in this
    example, the `Execution 3` is outdated.
    """
    aesthetic_print(
        "[bold cyan]Storm Workbench[/bold cyan]: Reproducible Update :leftwards_arrow_with_hook:",
        0,
    )

    workbench = obj["workbench"]
    try:
        workbench.session.op.update()
        workbench.session.save_session()

        aesthetic_print("[bold cyan]Storm Workbench[/bold cyan]: Finished!", 0)
    except:
        aesthetic_traceback(show_locals=True)


@operation.command(name="rerun")
@click.option(
    "--package",
    required=True,
    type=click.Path(
        exists=True, resolve_path=True, path_type=Path, dir_okay=False, file_okay=True
    ),
    help="Path to the Compendium Package that will be reproduced.",
)
@click.option(
    "-o",
    "--output-directory",
    required=True,
    type=click.Path(
        exists=False, resolve_path=True, path_type=Path, dir_okay=True, file_okay=False
    ),
    help="Directory where the results will be saved.",
)
@click.option(
    "-f",
    "--required-files-reference",
    required=False,
    type=click.Path(
        exists=True, resolve_path=True, path_type=Path, dir_okay=False, file_okay=True
    ),
    help="JSON file with the reference (Path and Checksum) files required to reproduce the experiment.",
)
@click.option(
    "-e",
    "--env",
    required=False,
    multiple=True,
    help="Environment variable required to reproduce the experiment (Multiple values allowed).",
)
@click.option(
    "-p",
    "--processes",
    required=False,
    type=int,
    default=2,
    help="Number of processes used to calculate the package files checksum during the import.",
)
def rerun(
    package, output_directory: Path, required_files_reference: Path, env, processes
):
    """Reproduce an experiment.

    This command load a Compendium package and reproduce it.
    """
    aesthetic_print(
        "[bold cyan]Storm Workbench[/bold cyan]: Experiment reproduction :alembic:"
    )

    try:
        output_directory.mkdir(parents=True, exist_ok=True)
        aesthetic_print(
            "[bold cyan]Storm Workbench[/bold cyan]: Checking the workbench definition :page_facing_up:"
        )

        # extracting the workbench definition file
        with ZipFile(package, "r") as izip:
            izip.extract(
                f"data/{WorkbenchDefinitions.WB_DEFINITION_FILE}", path=output_directory
            )

        # defining the working directories
        results_output = output_directory / "results"
        workbench_definition = (
            output_directory / "data" / WorkbenchDefinitions.WB_DEFINITION_FILE
        )

        # extracting the files from the package
        aesthetic_print(
            "[bold cyan]Storm Workbench[/bold cyan]: Loading the workbench data :game_die:"
        )
        BagItExporter.load(
            package,
            Workbench(workbench_definition).config.tool.storm.storage,
            processes=processes,
        )

        # creating the workbench context
        workbench = Workbench(workbench_definition)

        if required_files_reference:
            aesthetic_print(
                "[bold cyan]Storm Workbench[/bold cyan]: Loading the required files reference :file_cabinet:"
            )

            required_files_reference = json.load(required_files_reference.open())

        # reproducing!
        aesthetic_print(
            "[bold cyan]Storm Workbench[/bold cyan]: Reproducing the experiment :dragon:",
        )
        workbench.session.op.rerun(
            results_output, required_files_reference or None, env or None
        )
    except:
        aesthetic_traceback(show_locals=True)
    aesthetic_print("[bold cyan]Storm Workbench[/bold cyan]: Finished.", 0)
